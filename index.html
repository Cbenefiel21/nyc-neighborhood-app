<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NYC Explorer Vertical Wheel</title>
<style>
body {
  background-color: #121212;
  color: #fff;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  text-align: center;
  margin: 0;
  padding: 20px;
}
h1 { font-size: 24px; }
canvas {
  margin-top: 20px;
  background-color: #1e1e1e;
  border-radius: 12px;
}
button {
  background-color: #1d4ed8;
  color: white;
  border: none;
  padding: 12px 16px;
  border-radius: 8px;
  font-size: 16px;
  margin: 12px;
  cursor: pointer;
}
button.secondary {
  background-color: #6b7280;
}
</style>
</head>
<body>

<h1>NYC Explorer Arcade Wheel</h1>
<canvas id="wheel" width="400" height="500"></canvas>
<div id="selected" style="margin-top: 20px; font-size: 20px;">Tap "Spin"!</div>
<button onclick="spinWheel()">Spin</button>
<button class="secondary" onclick="resetList()">Reset</button>

<script>
// 39 Manhattan neighborhoods
const allNeighborhoods = [
"Battery Park","Battery Park City","Financial District","South Street Seaport","Tribeca",
"Civic Center","Chinatown","Little Italy","Lower East Side","Two Bridges",
"Bowery","NoHo","Greenwich Village","West Village","SoHo","Nolita","Flatiron District",
"Gramercy","Union Square","Kips Bay","Murray Hill","Turtle Bay",
"Midtown East","Midtown West","Hell's Kitchen","Clinton","Garment District",
"Chelsea","Meatpacking District","Hudson Yards",
"Upper East Side","Upper West Side","Harlem","East Harlem","Morningside Heights",
"Hamilton Heights","Manhattanville","Washington Heights","Inwood"
];

// Visited neighborhoods
let visited = JSON.parse(localStorage.getItem("visitedNeighborhoods")) || [];

// Canvas setup
const canvas = document.getElementById('wheel');
const ctx = canvas.getContext('2d');
const width = canvas.width;
const height = canvas.height;
const centerX = width/2;
const centerY = height/2;
const wheelRadius = 180;

let rotation = 0; // current rotation angle (radians)

// Draw vertical cylindrical wheel
function drawWheel(highlightIndex = null) {
  ctx.clearRect(0,0,width,height);
  const sliceAngle = (2*Math.PI)/allNeighborhoods.length;

  allNeighborhoods.forEach((n, i) => {
    // Compute angle of wedge relative to top pointer
    let angle = (i*sliceAngle + rotation) % (2*Math.PI);

    // Map to vertical position
    const y = Math.sin(angle) * wheelRadius;
    const scale = 0.5 + 0.5 * Math.cos(angle); // front wedge bigger, back smaller
    const alpha = 0.3 + 0.7 * Math.cos(angle); // fade back wedges

    // Only draw front-facing wedges (alpha > 0.1)
    if (alpha > 0.05) {
      ctx.save();
      ctx.translate(centerX, centerY + y);
      ctx.scale(scale, scale);

      // Determine fill color
      let isHighlight = highlightIndex !== null && i === highlightIndex;
      let fill;
      if (visited.includes(n)) fill = '#555';
      else if (isHighlight) fill = '#ffeb3b';
      else fill = (i % 2 === 0 ? '#1d4ed8' : '#2563eb');

      ctx.fillStyle = fill;
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.roundRect(-150, -20, 300, 40, 8);
      ctx.fill();

      // Text
      ctx.fillStyle = '#fff';
      ctx.font = "14px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(n, 0, 0);
      ctx.restore();
    }
  });

  // Draw fixed top pointer
  ctx.globalAlpha = 1;
  ctx.fillStyle = "#ffeb3b";
  ctx.beginPath();
  ctx.moveTo(centerX, centerY - wheelRadius - 20);
  ctx.lineTo(centerX - 15, centerY - wheelRadius + 10);
  ctx.lineTo(centerX + 15, centerY - wheelRadius + 10);
  ctx.closePath();
  ctx.fill();
}

// Smooth spin with deceleration
function spinWheel() {
  const remaining = allNeighborhoods.filter(n => !visited.includes(n));
  if (remaining.length === 0) {
    document.getElementById("selected").innerText = "You've visited all neighborhoods!";
    return;
  }

  const sliceAngle = (2*Math.PI)/allNeighborhoods.length;
  const pickedIndex = Math.floor(Math.random() * remaining.length);

  // Compute target rotation so picked wedge aligns under top pointer
  const spins = Math.random() * 5 + 5; // random full spins
  const targetRotation = 2*Math.PI*spins - pickedIndex*sliceAngle;

  const duration = 4000; // 4 seconds
  let start = null;

  function animate(timestamp) {
    if (!start) start = timestamp;
    const elapsed = timestamp - start;
    const t = Math.min(elapsed/duration, 1);

    rotation = targetRotation * easeOutQuart(t);

    drawWheel(pickedIndex);

    if (t < 1) {
      requestAnimationFrame(animate);
    } else {
      const chosen = remaining[pickedIndex];
      visited.push(chosen);
      localStorage.setItem("visitedNeighborhoods", JSON.stringify(visited));
      document.getElementById("selected").innerText = `Next: ${chosen}`;
      drawWheel(); // final draw without highlight
    }
  }
  requestAnimationFrame(animate);
}

// Quartic easing for smooth deceleration
function easeOutQuart(t) { return 1 - Math.pow(1 - t, 4); }

function resetList() {
  if (confirm("Reset visited neighborhoods?")) {
    visited = [];
    localStorage.setItem("visitedNeighborhoods", JSON.stringify(visited));
    document.getElementById("selected").innerText = 'Tap "Spin"!';
    drawWheel();
  }
}

// Polyfill for rounded rect (for older browsers)
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    this.beginPath();
    this.moveTo(x+r, y);
    this.arcTo(x+w, y, x+w, y+h, r);
    this.arcTo(x+w, y+h, x, y+h, r);
    this.arcTo(x, y+h, x, y, r);
    this.arcTo(x, y, x+w, y, r);
    this.closePath();
    return this;
  }
}

// Initial draw
drawWheel();
</script>

</body>
</html>

