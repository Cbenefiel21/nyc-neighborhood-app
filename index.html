<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NYC Explorer Arcade Wheel</title>
<style>
body {
  background-color: #121212;
  color: #fff;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  text-align: center;
  margin: 0;
  padding: 20px;
}
h1 { font-size: 24px; }
canvas {
  margin-top: 20px;
  background-color: #1e1e1e;
  border-radius: 12px;
}
button {
  background-color: #1d4ed8;
  color: white;
  border: none;
  padding: 12px 16px;
  border-radius: 8px;
  font-size: 16px;
  margin: 12px;
  cursor: pointer;
}
button.secondary {
  background-color: #6b7280;
}
</style>
</head>
<body>

<h1>NYC Explorer Arcade Wheel</h1>
<canvas id="wheel" width="400" height="500"></canvas>
<div id="selected" style="margin-top: 20px; font-size: 20px;">Tap "Spin"!</div>
<button onclick="spinWheel()">Spin</button>
<button class="secondary" onclick="resetList()">Reset</button>

<script>
// Manhattan neighborhoods
const allNeighborhoods = [
"Battery Park","Battery Park City","Financial District","South Street Seaport","Tribeca",
"Civic Center","Chinatown","Little Italy","Lower East Side","Two Bridges",
"Bowery","NoHo","Greenwich Village","West Village","SoHo","Nolita","Flatiron District",
"Gramercy","Union Square","Kips Bay","Murray Hill","Turtle Bay",
"Midtown East","Midtown West","Hell's Kitchen","Clinton","Garment District",
"Chelsea","Meatpacking District","Hudson Yards",
"Upper East Side","Upper West Side","Harlem","East Harlem","Morningside Heights",
"Hamilton Heights","Manhattanville","Washington Heights","Inwood"
];

let visited = JSON.parse(localStorage.getItem("visitedNeighborhoods")) || [];

const canvas = document.getElementById('wheel');
const ctx = canvas.getContext('2d');
const width = canvas.width;
const height = canvas.height;
const centerX = width/2;
const centerY = height/2;
const wheelRadius = 180;

let rotation = 0;
let spinning = false;

// Draw wheel with back-to-front sorting
function drawWheel(highlightFront=false) {
  ctx.clearRect(0,0,width,height);
  const sliceAngle = (2*Math.PI)/allNeighborhoods.length;

  // Compute positions with depth
  const wedges = allNeighborhoods.map((n,i) => {
    const angle = (i*sliceAngle + rotation) % (2*Math.PI);
    const y = Math.sin(angle)*wheelRadius;
    const scale = 0.5 + 0.5*Math.cos(angle); // front bigger
    const alpha = 0.3 + 0.7*Math.cos(angle); // back fades
    return {name: n, index:i, angle, y, scale, alpha};
  });

  // Sort back-to-front
  wedges.sort((a,b)=>a.scale-b.scale);

  wedges.forEach(w => {
    if (w.alpha<0.05) return;
    ctx.save();
    ctx.translate(centerX, centerY + w.y);
    ctx.scale(w.scale,w.scale);

    // Fill color
    let isFront = highlightFront && Math.abs(Math.sin(w.angle))<0.01;
    let fill;
    if (visited.includes(w.name)) fill = '#555';
    else if (isFront) fill = '#ffeb3b';
    else fill = (w.index%2===0 ? '#1d4ed8':'#2563eb');

    ctx.fillStyle = fill;
    ctx.globalAlpha = w.alpha;
    ctx.beginPath();
    ctx.roundRect(-150,-20,300,40,8);
    ctx.fill();

    // Text
    ctx.fillStyle='#fff';
    ctx.font="14px sans-serif";
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.fillText(w.name,0,0);

    ctx.restore();
  });

  ctx.globalAlpha = 1;
  // Side pointer (middle-right), flipped toward wheel
  ctx.fillStyle="#ffeb3b";
  ctx.beginPath();
  ctx.moveTo(width-10, centerY);
  ctx.lineTo(width+10, centerY-10);
  ctx.lineTo(width+10, centerY+10);
  ctx.closePath();
  ctx.fill();
}

// Spin wheel
function spinWheel(){
  if(spinning) return;
  spinning = true;
  document.getElementById("selected").innerText = "Spinning...";

  const spins = Math.random()*5+5; // full rotations
  const totalRotation = 2*Math.PI*spins + Math.random()*2*Math.PI; 
  const duration = 4000;
  let start=null;

  function animate(timestamp){
    if(!start) start=timestamp;
    const elapsed = timestamp-start;
    const t = Math.min(elapsed/duration,1);
    rotation = totalRotation*easeOutQuart(t);
    drawWheel(false);
    if(t<1) requestAnimationFrame(animate);
    else {
      // Pick the front wedge as the selected neighborhood
      const sliceAngle = (2*Math.PI)/allNeighborhoods.length;
      let frontIndex = Math.round((-rotation)/sliceAngle) % allNeighborhoods.length;
      if(frontIndex<0) frontIndex+=allNeighborhoods.length;
      const chosen = allNeighborhoods[frontIndex];
      visited.push(chosen);
      localStorage.setItem("visitedNeighborhoods",JSON.stringify(visited));
      drawWheel(true); // highlight
      document.getElementById("selected").innerText = `Next: ${chosen}`;
      spinning=false;
    }
  }
  requestAnimationFrame(animate);
}

function easeOutQuart(t){ return 1-Math.pow(1-t,4); }

function resetList(){
  if(confirm("Reset visited neighborhoods?")){
    visited=[];
    localStorage.setItem("visitedNeighborhoods",JSON.stringify(visited));
    document.getElementById("selected").innerText='Tap "Spin"!';
    drawWheel();
  }
}

// Polyfill for roundRect
if(!CanvasRenderingContext2D.prototype.roundRect){
  CanvasRenderingContext2D.prototype.roundRect=function(x,y,w,h,r){
    if(w<2*r) r=w/2;
    if(h<2*r) r=h/2;
    this.beginPath();
    this.moveTo(x+r,y);
    this.arcTo(x+w,y,x+w,y+h,r);
    this.arcTo(x+w,y+h,x,y+h,r);
    this.arcTo(x,y+h,x,y,r);
    this.arcTo(x,y,x+w,y,r);
    this.closePath();
    return this;
  }
}

drawWheel();
</script>

</body>
</html>
